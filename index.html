<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dozer — guided coins (phys-only bigger coins)</title>
<style>
  html,body{margin:0;padding:0;background:#000;overflow:hidden;width:100%;height:100%}
  #gameCanvas{position:absolute;top:0;left:0;width:1080px;height:1920px;transform-origin:top left;display:block;background:#000}
</style>
</head>
<body>
<canvas id="gameCanvas" width="1080" height="1920"></canvas>

<script>
(()=>{
// ---------- Layout (НЕ МЕНЯЕМ, поле остаётся прежним) ----------
const W=1080,H=1920,TOP=140;

const BASE_R=64;              // базовый радиус ТОЛЬКО для расчёта ширины канала и прочей геометрии
const D=BASE_R*2;
const CHANNEL_W=D*7;
const X_LEFT=W/2-CHANNEL_W/2;
const X_RIGHT=X_LEFT+CHANNEL_W;
const X_CENTER=(X_LEFT+X_RIGHT)/2;
const Y_TOP=TOP;

const DOCK_H=260;
const Y_CHANNEL_BOTTOM=H-DOCK_H;
const Y_BOTTOM=Y_CHANNEL_BOTTOM+DOCK_H;

// dozer
const DZ_W=CHANNEL_W*0.6, DZ_H=360, DZ_X=W/2-DZ_W/2;
const DZ_PUSH_V=320, DZ_BACK_V=380;
const DZ_TOP_MAX=Y_CHANNEL_BOTTOM, DZ_TOP_MIN=H+80;

// bottom blocks + pocket
const LEFT_BLOCK ={x:X_LEFT,    y:Y_CHANNEL_BOTTOM, w:DZ_X-X_LEFT,        h:DOCK_H};
const RIGHT_BLOCK={x:DZ_X+DZ_W, y:Y_CHANNEL_BOTTOM, w:X_RIGHT-(DZ_X+DZ_W),h:DOCK_H};
const POCKET={x:DZ_X, y:Y_CHANNEL_BOTTOM, w:DZ_W, h:DOCK_H};

// side pits (at edges)
const PIT_TOP   = Y_TOP + D*1.4;
const PIT_BOTTOM= Y_CHANNEL_BOTTOM - D*4;
const PIT_H     = Math.max(100, PIT_BOTTOM-PIT_TOP);
const PIT_VIS_W = Math.min(100, X_LEFT-8);
const PIT_LEFT  ={y:PIT_TOP,  h:PIT_H};
const PIT_RIGHT ={y:PIT_TOP,  h:PIT_H};

// 45° corners
const TRI=220;
const LT_INNER ={x:DZ_X,      y:Y_CHANNEL_BOTTOM};
const LT_CORNER={x:X_LEFT,    y:Y_CHANNEL_BOTTOM};
const LT_WALL  ={x:X_LEFT,    y:Y_CHANNEL_BOTTOM-TRI};
const RT_INNER ={x:DZ_X+DZ_W, y:Y_CHANNEL_BOTTOM};
const RT_CORNER={x:X_RIGHT,   y:Y_CHANNEL_BOTTOM};
const RT_WALL  ={x:X_RIGHT,   y:Y_CHANNEL_BOTTOM-TRI};

// ---------- Coin size (МЕНЯЕМ ТОЛЬКО МОНЕТЫ) ----------
const COIN_R_PHYS = 77;   // физический радиус монеты (коллизии). Меняй тут.
const COIN_R_DRAW = 77;   // визуальный размер (рисунок). Можно = COIN_R_PHYS или больше/меньше.

// ---------- Physics (более «управляемые») ----------
const GRAVITY=0.28;
const FRICTION_X=0.925;
const FRICTION_Y=0.985;
const CONTACT_DAMP=0.975;
const CONTACT_STIFF=0.26;
const SIDE_IMP=1.0;
const CENTER_PULL=0.22;

// ---------- State ----------
const cvs=document.getElementById('gameCanvas'), ctx=cvs.getContext('2d');
const coins=[], particles=[];
let dzTop=H+80, dzPhase='push';

// counter + regen
let bank=50, regenActive=false, regenLeft=0, regenTick=0;

// ---------- Utils ----------
function resize(){
  const s=Math.min(innerWidth/W, innerHeight/H);
  cvs.style.transform=`scale(${s})`;
  cvs.style.left=`${(innerWidth-W*s)/2}px`;
  cvs.style.top =`${(innerHeight-H*s)/2}px`;
}
function rand(a,b){return a+Math.random()*(b-a);}
function toGame(e){
  const r=cvs.getBoundingClientRect(), sx=W/r.width, sy=H/r.height;
  const cx=(e.touches?e.touches[0].clientX:e.clientX)-r.left;
  const cy=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
  return {x:cx*sx,y:cy*sy};
}
function startRegen(){ if(!regenActive && bank===0){ regenActive=true; regenLeft=15; regenTick=0; } }

// ---------- Particles ----------
function spawnParticles(x,y){
  for(let i=0;i<12;i++)
    particles.push({x,y,vx:rand(-110,110),vy:rand(-220,-60),life:1,size:rand(3,6)});
}
function updParticles(dt){
  for(const p of particles){ p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=220*dt; p.life-=1.6*dt; }
  for(let i=particles.length-1;i>=0;i--) if(particles[i].life<=0) particles.splice(i,1);
}
function drawParticles(){
  for(const p of particles){ ctx.globalAlpha=p.life; ctx.fillStyle="#fff230";
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;
}

// ---------- Coins ----------
function spawnCoinAt(x,y){ coins.push({x,y,rPhys:COIN_R_PHYS,vx:0,vy:0}); }
function trySpawn(e){
  e.preventDefault();
  const {x,y}=toGame(e);
  if(x<POCKET.x||x>POCKET.x+POCKET.w||y<POCKET.y||y>POCKET.y+POCKET.h) return;
  if(bank<=0){ startRegen(); return; }
  bank--; spawnCoinAt(x,y); if(bank===0) startRegen();
}
function initCoins(){
  for(let i=0;i<40;i++){
    coins.push({
      x:W/2+rand(-CHANNEL_W*0.25,CHANNEL_W*0.25),
      y:rand(TOP+COIN_R_PHYS+40, Y_CHANNEL_BOTTOM-COIN_R_PHYS-40),
      rPhys:COIN_R_PHYS,
      vx:rand(-20,20),
      vy:rand(-15,15)
    });
  }
}

// ---------- Collision helpers ----------
function circleVsRect_UpwardPush(c, rx,ry,rw,rh){
  let cx=Math.max(rx,Math.min(c.x,rx+rw));
  let cy=Math.max(ry,Math.min(c.y,ry+rh));
  const dx=c.x-cx, dy=c.y-cy, d2=dx*dx+dy*dy, r2=c.rPhys*c.rPhys;
  if(d2<r2){
    const d=Math.sqrt(d2)||0.0001, ov=c.rPhys-d, nx=dx/d, ny=dy/d;
    c.x+=nx*ov; c.y+=ny*ov;
    const pushX = nx*4;
    const pushY = Math.max(0, ny)*22;
    c.vx+=pushX; c.vy+=pushY;
    c.vx*=CONTACT_DAMP; c.vy*=CONTACT_DAMP;
  }
}
function circleVsRect(c, rx,ry,rw,rh, push=10){
  let cx=Math.max(rx,Math.min(c.x,rx+rw));
  let cy=Math.max(ry,Math.min(c.y,ry+rh));
  const dx=c.x-cx, dy=c.y-cy, d2=dx*dx+dy*dy, r2=c.rPhys*c.rPhys;
  if(d2<r2){
    const d=Math.sqrt(d2)||0.0001, ov=c.rPhys-d, nx=dx/d, ny=dy/d;
    c.x+=nx*ov; c.y+=ny*ov; c.vx+=nx*push; c.vy+=ny*push; c.vx*=CONTACT_DAMP; c.vy*=CONTACT_DAMP;
  }
}
function circleVsSegment(c, A,B, push=8){
  const vx=B.x-A.x, vy=B.y-A.y, len2=vx*vx+vy*vy||1;
  let t=((c.x-A.x)*vx+(c.y-A.y)*vy)/len2; t=Math.max(0,Math.min(1,t));
  const px=A.x+vx*t, py=A.y+vy*t;
  const dx=c.x-px, dy=c.y-py, d2=dx*dx+dy*dy, r2=c.rPhys*c.rPhys;
  if(d2<r2){
    const d=Math.sqrt(d2)||0.0001, ov=c.rPhys-d, nx=dx/d, ny=dy/d;
    c.x+=nx*ov; c.y+=ny*ov; c.vx+=nx*push; c.vy+=ny*push; c.vx*=CONTACT_DAMP; c.vy*=CONTACT_DAMP;
  }
}

// ---------- Update ----------
function updDozer(dt){
  if(dzPhase==='push'){ dzTop-=DZ_PUSH_V*dt; if(dzTop<DZ_TOP_MAX){dzTop=DZ_TOP_MAX; dzPhase='back';}}
  else{ dzTop+=DZ_BACK_V*dt; if(dzTop>DZ_TOP_MIN){dzTop=DZ_TOP_MIN; dzPhase='push';}}
}
function updCoins(dt){
  for(const c of coins){
    c.vy+=GRAVITY*dt;
    if(c.y>Y_TOP+(Y_CHANNEL_BOTTOM-Y_TOP)*0.35 && c.y<Y_CHANNEL_BOTTOM){
      c.vx += (X_CENTER - c.x) * (CENTER_PULL*dt);
    }
    c.y += c.vy*dt; c.x += c.vx*dt;
    c.vx *= Math.pow(FRICTION_X, 60*dt);
    c.vy *= Math.pow(FRICTION_Y, 60*dt);

    if(c.y<=Y_TOP){ spawnParticles(c.x,c.y); c._collect=true; continue; }

    if(c.y + c.rPhys > Y_BOTTOM){ c.y=Y_BOTTOM-c.rPhys; c.vy*=-0.15; }
  }
  for(let i=coins.length-1;i>=0;i--){
    if(coins[i]._collect){ coins.splice(i,1); bank++; if(bank>0){regenActive=false;} }
  }
}
function collideEnv(){
  for(const c of coins) circleVsRect_UpwardPush(c, DZ_X, dzTop, DZ_W, DZ_H);

  for(const c of coins){
    circleVsSegment(c, LT_INNER, LT_WALL, 7);
    circleVsSegment(c, RT_INNER, RT_WALL, 7);
  }

  for(const c of coins){
    circleVsRect(c, LEFT_BLOCK.x,LEFT_BLOCK.y,LEFT_BLOCK.w,LEFT_BLOCK.h, 6);
    circleVsRect(c, RIGHT_BLOCK.x,RIGHT_BLOCK.y,RIGHT_BLOCK.w,RIGHT_BLOCK.h,6);
  }

  for(const c of coins){
    if(c.y>=PIT_LEFT.y && c.y<=PIT_LEFT.y+PIT_LEFT.h){
      if(c.x<=X_LEFT) c._burn=true;
    }else{
      if(c.x - c.rPhys < X_LEFT){ c.x=X_LEFT+c.rPhys; c.vx*=-0.08; }
    }
    if(c.y>=PIT_RIGHT.y && c.y<=PIT_RIGHT.y+PIT_RIGHT.h){
      if(c.x>=X_RIGHT) c._burn=true;
    }else{
      if(c.x + c.rPhys > X_RIGHT){ c.x=X_RIGHT-c.rPhys; c.vx*=-0.08; }
    }
  }
  for(let i=coins.length-1;i>=0;i--) if(coins[i]._burn) coins.splice(i,1);
}
function separateCoins(){
  for(let it=0;it<2;it++){
    for(let i=0;i<coins.length;i++){
      for(let j=i+1;j<coins.length;j++){
        const a=coins[i], b=coins[j];
        const dx=b.x-a.x, dy=b.y-a.y, md=a.rPhys+b.rPhys, d2=dx*dx+dy*dy;
        if(d2<md*md){
          const d=Math.sqrt(d2)||0.0001, nx=dx/d, ny=dy/d, ov=(md-d)*CONTACT_STIFF;
          a.x-=nx*ov; a.y-=ny*ov; b.x+=nx*ov; b.y+=ny*ov;
          a.vx-=nx*SIDE_IMP*0.5; a.vy-=ny*SIDE_IMP*0.5;
          b.vx+=nx*SIDE_IMP*0.5; b.vy+=ny*SIDE_IMP*0.5;
          a.vx*=CONTACT_DAMP; a.vy*=CONTACT_DAMP;
          b.vx*=CONTACT_DAMP; b.vy*=CONTACT_DAMP;
        }
      }
    }
  }
}

// regen
function updateRegen(dt){
  if(!regenActive) return;
  regenTick += dt;
  while(regenTick>=1){
    regenTick-=1; regenLeft=Math.max(0,regenLeft-1);
    if(regenLeft===0){ bank+=1; regenActive=false; }
  }
}

// ---------- Draw ----------
function drawTopBar(){
  const g=ctx.createLinearGradient(0,0,0,TOP);
  g.addColorStop(0,"#2fd144"); g.addColorStop(1,"#1a6f2f");
  ctx.fillStyle=g; ctx.fillRect(0,0,W,TOP);

  ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.font="bold 64px system-ui";
  if(regenActive) ctx.fillText(`COINS: ${bank}  (${regenLeft}s)`, W/2, TOP/2);
  else            ctx.fillText(`COINS: ${bank}`,               W/2, TOP/2);
}
function drawChannel(){ ctx.fillStyle="#0b4f8a"; ctx.fillRect(X_LEFT,Y_TOP,CHANNEL_W,Y_CHANNEL_BOTTOM-Y_TOP); }
function drawSideWallsAndPits(){
  ctx.fillStyle="#ff4f4f";
  ctx.fillRect(0,TOP, X_LEFT, H-TOP);
  ctx.fillRect(X_RIGHT,TOP, W-X_RIGHT, H-TOP);
  ctx.fillStyle="#000";
  ctx.fillRect(0, PIT_LEFT.y, PIT_VIS_W, PIT_LEFT.h);
  ctx.fillRect(W-PIT_VIS_W, PIT_RIGHT.y, PIT_VIS_W, PIT_RIGHT.h);
}
function drawCorners(){
  ctx.fillStyle="#b01779";
  ctx.beginPath(); ctx.moveTo(LT_INNER.x,LT_INNER.y); ctx.lineTo(LT_CORNER.x,LT_CORNER.y); ctx.lineTo(LT_WALL.x,LT_WALL.y); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(RT_INNER.x,RT_INNER.y); ctx.lineTo(RT_CORNER.x,RT_CORNER.y); ctx.lineTo(RT_WALL.x,RT_WALL.y); ctx.closePath(); ctx.fill();
}
function drawDock(){
  ctx.fillStyle="#ff4f4f";
  ctx.fillRect(LEFT_BLOCK.x, LEFT_BLOCK.y, LEFT_BLOCK.w, LEFT_BLOCK.h);
  ctx.fillRect(RIGHT_BLOCK.x,RIGHT_BLOCK.y,RIGHT_BLOCK.w,RIGHT_BLOCK.h);
  ctx.fillStyle="#000";
  ctx.fillRect(POCKET.x, POCKET.y, POCKET.w, POCKET.h);
}
function drawDozer(){ ctx.fillStyle="#6aff1f"; ctx.fillRect(DZ_X,dzTop,DZ_W,DZ_H); }
function drawCoins(){
  for(const c of coins){
    // тень
    ctx.fillStyle="#d87b00";
    ctx.beginPath(); ctx.arc(c.x,c.y+10,COIN_R_DRAW,0,Math.PI*2); ctx.fill();
    // тело
    ctx.fillStyle="#fff230";
    ctx.beginPath(); ctx.arc(c.x,c.y,COIN_R_DRAW,0,Math.PI*2); ctx.fill();
    // контур
    ctx.lineWidth=3; ctx.strokeStyle="#b86a00"; ctx.stroke();
  }
}

// ---------- Loop ----------
function update(dt){
  updDozer(dt);
  updCoins(dt);
  collideEnv();
  separateCoins();
  updParticles(dt);
  updateRegen(dt);
}
function draw(){
  ctx.clearRect(0,0,W,H);
  drawTopBar();
  drawChannel();
  drawSideWallsAndPits();
  drawCorners();
  drawDock();
  drawDozer();
  drawCoins();
  drawParticles();
}
let last=performance.now();
function loop(t){ const dt=(t-last)/1000; last=t; update(dt); draw(); requestAnimationFrame(loop); }

// ---------- Boot ----------
cvs.addEventListener('mousedown', trySpawn);
cvs.addEventListener('touchstart', trySpawn, {passive:false});
initCoins();
addEventListener('load', ()=>{ resize(); last=performance.now(); requestAnimationFrame(loop); });
addEventListener('resize', resize);
})();
</script>
</body>
</html>
