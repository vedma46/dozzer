<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dozer — guided coins + RED/GREEN + Tutorial spotlight + TopBar FX (fix)</title>
<style>
  html,body{margin:0;padding:0;background:#000;overflow:hidden;width:100%;height:100%}
  #gameCanvas{position:absolute;top:0;left:0;width:1080px;height:1920px;transform-origin:top left;display:block;background:#000}
</style>
</head>
<body>
<canvas id="gameCanvas" width="1080" height="1920"></canvas>

<script>
(()=>{
// ---------- Layout ----------
const W=1080,H=1920,TOP=140;

const BASE_R=64;
const D=BASE_R*2;
const CHANNEL_W=D*7;
const X_LEFT=W/2-CHANNEL_W/2;
const X_RIGHT=X_LEFT+CHANNEL_W;
const X_CENTER=(X_LEFT+X_RIGHT)/2;
const Y_TOP=TOP;

const DOCK_H=260;
const Y_CHANNEL_BOTTOM=H-DOCK_H;
const Y_BOTTOM=Y_CHANNEL_BOTTOM+DOCK_H;

// dozer
const DZ_W=CHANNEL_W*0.6, DZ_H=1920, DZ_X=W/2-DZ_W/2;
const DZ_PUSH_V=320, DZ_BACK_V=380;
const DZ_TOP_MAX=Y_CHANNEL_BOTTOM, DZ_TOP_MIN=H+80;
const DZ_MEGA_TARGET=H/2;

// bottom blocks + pocket
const LEFT_BLOCK ={x:X_LEFT,    y:Y_CHANNEL_BOTTOM, w:DZ_X-X_LEFT,        h:DOCK_H};
const RIGHT_BLOCK={x:DZ_X+DZ_W, y:Y_CHANNEL_BOTTOM, w:X_RIGHT-(DZ_X+DZ_W),h:DOCK_H};
const POCKET={x:DZ_X, y:Y_CHANNEL_BOTTOM, w:DZ_W, h:DOCK_H};

// side pits
const PIT_TOP   = Y_TOP + D*1.4;
const PIT_BOTTOM= Y_CHANNEL_BOTTOM - D*4;
const PIT_H     = Math.max(100, PIT_BOTTOM-PIT_TOP);
const PIT_VIS_W = Math.min(100, X_LEFT-8);
const PIT_LEFT  ={y:PIT_TOP,  h:PIT_H};
const PIT_RIGHT ={y:PIT_TOP,  h:PIT_H};

// 45° corners
const TRI=220;
const LT_INNER ={x:DZ_X,      y:Y_CHANNEL_BOTTOM};
const LT_CORNER={x:X_LEFT,    y:Y_CHANNEL_BOTTOM};
const LT_WALL  ={x:X_LEFT,    y:Y_CHANNEL_BOTTOM-TRI};
const RT_INNER ={x:DZ_X+DZ_W, y:Y_CHANNEL_BOTTOM};
const RT_CORNER={x:X_RIGHT,   y:Y_CHANNEL_BOTTOM};
const RT_WALL  ={x:X_RIGHT,   y:Y_CHANNEL_BOTTOM-TRI};

// ---------- Coin size ----------
const COIN_R_PHYS = 77;
const COIN_R_DRAW = 77;

// ---------- Physics ----------
const GRAVITY=0.48;
const FRICTION_X=0.925;
const FRICTION_Y=0.985;
const CONTACT_DAMP=1.0;
const CONTACT_STIFF=0.26;
const SIDE_IMP=1.0;
const CENTER_PULL=0.22;

// ---------- State ----------
const cvs=document.getElementById('gameCanvas'), ctx=cvs.getContext('2d');
const coins=[], particles=[];
let dzTop=H+80, dzPhase='push';
let dzMode='normal';  // 'normal' | 'mega_push' | 'mega_back'
let megaQueue=0;

let bank=101, regenActive=false, regenLeft=0, regenTick=0;

// special coins timers
const RED_SPAWN_INTERVAL   = 60;
const GREEN_SPAWN_INTERVAL = 30;
let timeElapsed=0, nextRedAt=0, nextGreenAt=0;

// ---------- Tutorial ----------
const tutorial = { visible:true };

// ---------- TopBar FX ----------
let barAnimT = 0;
const BAR_ANIM_DUR = 1.2;
const twinkles = [];
const barBursts = [];
const TWINKLE_COUNT = 22;

function initTopBarStars(){
  twinkles.length=0;
  for(let i=0;i<TWINKLE_COUNT;i++){
    twinkles.push({
      x: Math.random()*W,
      y: Math.random()*TOP,
      r: 1.5 + Math.random()*2.2,
      phase: Math.random()*Math.PI*2,
      speed: 1.2 + Math.random()*1.8,
      drift: (Math.random()*2-1)*10
    });
  }
}
function triggerBarFX(x){
  barAnimT = BAR_ANIM_DUR;
  for(let i=0;i<24;i++){
    barBursts.push({
      x: x + (Math.random()*2-1)*20,
      y: Y_TOP - 6 + Math.random()*12,
      vx: (Math.random()*2-1)*140,
      vy: -40 - Math.random()*120,
      life: 1,
      r: 2 + Math.random()*3
    });
  }
}
function updateTopBarFX(dt){
  if(barAnimT>0) barAnimT=Math.max(0,barAnimT-dt);
  for(const s of twinkles){
    s.phase += dt*s.speed;
    s.x += s.drift*dt*0.2;
    if(s.x<-10) s.x=W+10; if(s.x>W+10) s.x=-10;
  }
  for(const b of barBursts){
    b.x+=b.vx*dt; b.y+=b.vy*dt;
    b.vx*=0.98; b.vy*=0.98;
    b.life-=1.6*dt;
  }
  for(let i=barBursts.length-1;i>=0;i--) if(barBursts[i].life<=0) barBursts.splice(i,1);
}

// ---------- Utils ----------
function resize(){
  const s=Math.min(innerWidth/W, innerHeight/H);
  cvs.style.transform=`scale(${s})`;
  cvs.style.left=`${(innerWidth-W*s)/2}px`;
  cvs.style.top =`${(innerHeight-H*s)/2}px`;
}
function rand(a,b){return a+Math.random()*(b-a);}
function toGame(e){
  const r=cvs.getBoundingClientRect(), sx=W/r.width, sy=H/r.height;
  const cx=(e.touches?e.touches[0].clientX:e.clientX)-r.left;
  const cy=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
  return {x:cx*sx,y:cy*sy};
}
function startRegen(){ if(!regenActive && bank===0){ regenActive=true; regenLeft=15; regenTick=0; } }

// ---------- Particles ----------
function spawnParticles(x,y){
  for(let i=0;i<12;i++)
    particles.push({x,y,vx:rand(-110,110),vy:rand(-220,-60),life:1,size:rand(3,6)});
}
function updParticles(dt){
  for(const p of particles){ p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=220*dt; p.life-=1.6*dt; }
  for(let i=particles.length-1;i>=0;i--) if(particles[i].life<=0) particles.splice(i,1);
}
function drawParticles(){
  for(const p of particles){ ctx.globalAlpha=p.life; ctx.fillStyle="#fff230";
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;
}

// ---------- Coins ----------
function spawnCoinAt(x,y,isRed=false,isGreen=false){
  const coin={x,y,rPhys:COIN_R_PHYS,vx:0,vy:0,isRed,isGreen};
  if(isGreen){ coin.rPhys=COIN_R_PHYS*2; }
  coins.push(coin);
}
function trySpawn(e){
  e.preventDefault();
  const {x,y}=toGame(e);
  if(x<POCKET.x||x>POCKET.x+POCKET.w||y<POCKET.y||y>POCKET.y+POCKET.h) return;
  if(bank<=0){ startRegen(); return; }
  bank--; spawnCoinAt(x,y,false,false); if(bank===0) startRegen();
}
function handleInput(e){
  if(tutorial.visible){
    const before=bank;
    trySpawn(e);
    if(bank<before){ tutorial.visible=false; }
    return;
  }
  trySpawn(e);
}
function initCoins(){
  for(let i=0;i<40;i++){
    coins.push({
      x:W/2+rand(-CHANNEL_W*0.25,CHANNEL_W*0.25),
      y:rand(TOP+COIN_R_PHYS+40, Y_CHANNEL_BOTTOM-COIN_R_PHYS-40),
      rPhys:COIN_R_PHYS,
      vx:rand(-20,20),
      vy:rand(-15,15),
      isRed:false,
      isGreen:false
    });
  }
  initTopBarStars();
}

// ---------- Collision helpers ----------
function circleVsRect_UpwardPush(c, rx,ry,rw,rh){
  let cx=Math.max(rx,Math.min(c.x,rx+rw));
  let cy=Math.max(ry,Math.min(c.y,ry+rh));
  const dx=c.x-cx, dy=c.y-cy, d2=dx*dx+dy*dy, r2=c.rPhys*c.rPhys;
  if(d2<r2){
    const d=Math.sqrt(d2)||0.0001, ov=c.rPhys-d, nx=dx/d, ny=dy/d;
    c.x+=nx*ov; c.y+=ny*ov;
    const pushX=nx*4, pushY=Math.max(0,ny)*22;
    c.vx+=pushX; c.vy+=pushY;
    c.vx*=CONTACT_DAMP; c.vy*=CONTACT_DAMP;
  }
}
function circleVsRect(c, rx,ry,rw,rh, push=10){
  let cx=Math.max(rx,Math.min(c.x,rx+rw));
  let cy=Math.max(ry,Math.min(c.y,ry+rh));
  const dx=c.x-cx, dy=c.y-cy, d2=dx*dx+dy*dy, r2=c.rPhys*c.rPhys;
  if(d2<r2){
    const d=Math.sqrt(d2)||0.0001, ov=c.rPhys-d, nx=dx/d, ny=dy/d;
    c.x+=nx*ov; c.y+=ny*ov; c.vx+=nx*push; c.vy+=ny*push; c.vx*=CONTACT_DAMP; c.vy*=CONTACT_DAMP;
  }
}
function circleVsSegment(c, A,B, push=8){
  const vx=B.x-A.x, vy=B.y-A.y, len2=vx*vx+vy*vy||1;
  let t=((c.x-A.x)*vx+(c.y-A.y)*vy)/len2; t=Math.max(0,Math.min(1,t));
  const px=A.x+vx*t, py=A.y+vy*t;
  const dx=c.x-px, dy=c.y-py, d2=dx*dx+dy*dy, r2=c.rPhys*c.rPhys;
  if(d2<r2){
    const d=Math.sqrt(d2)||0.0001, ov=c.rPhys-d, nx=dx/d, ny=dy/d;
    c.x+=nx*ov; c.y+=ny*ov; c.vx+=nx*push; c.vy+=ny*push; c.vx*=CONTACT_DAMP; c.vy*=CONTACT_DAMP;
  }
}

// ---------- Update ----------
function updDozer(dt){
  if(dzMode==='mega_push'){
    dzTop -= DZ_PUSH_V*dt*1.15;
    if(dzTop < DZ_MEGA_TARGET){ dzTop=DZ_MEGA_TARGET; dzMode='mega_back'; }
    return;
  }
  if(dzMode==='mega_back'){
    dzTop += DZ_BACK_V*dt*1.15;
    if(dzTop > DZ_TOP_MIN){
      dzTop=DZ_TOP_MIN;
      if(megaQueue>0){ megaQueue--; dzMode='mega_push'; }
      else { dzMode='normal'; dzPhase='push'; }
    }
    return;
  }
  if(dzPhase==='push'){ dzTop-=DZ_PUSH_V*dt; if(dzTop<DZ_TOP_MAX){dzTop=DZ_TOP_MAX; dzPhase='back';}}
  else{ dzTop+=DZ_BACK_V*dt; if(dzTop>DZ_TOP_MIN){dzTop=DZ_TOP_MIN; dzPhase='push';}}
}

function spawnSixPocketCoins(){
  for(let i=0;i<6;i++){
    const x = rand(POCKET.x+COIN_R_PHYS, POCKET.x+POCKET.w-COIN_R_PHYS);
    const y = rand(POCKET.y+COIN_R_PHYS, POCKET.y+POCKET.h-COIN_R_PHYS);
    coins.push({x,y,rPhys:COIN_R_PHYS,vx:rand(-10,10),vy:rand(-5,5),isRed:false,isGreen:false});
  }
}

function updCoins(dt){
  timeElapsed += dt;
  while(timeElapsed >= nextRedAt){
    const rx = rand(X_LEFT+COIN_R_PHYS, X_RIGHT-COIN_R_PHYS);
    const ry = rand(Y_TOP+COIN_R_PHYS, Y_CHANNEL_BOTTOM-COIN_R_PHYS);
    spawnCoinAt(rx, ry, true, false);
    nextRedAt += RED_SPAWN_INTERVAL;
  }
  while(timeElapsed >= nextGreenAt){
    const gx = rand(X_LEFT+COIN_R_PHYS*2, X_RIGHT-COIN_R_PHYS*2);
    const gy = rand(Y_TOP+COIN_R_PHYS*2, Y_CHANNEL_BOTTOM-COIN_R_PHYS*2);
    spawnCoinAt(gx, gy, false, true);
    nextGreenAt += GREEN_SPAWN_INTERVAL;
  }

  for(const c of coins){
    c.vy += GRAVITY*dt;
    if(c.y>Y_TOP+(Y_CHANNEL_BOTTOM-Y_TOP)*0.35 && c.y<Y_CHANNEL_BOTTOM){
      c.vx += (X_CENTER - c.x) * (CENTER_PULL*dt);
    }
    c.y += c.vy*dt; c.x += c.vx*dt;
    c.vx *= Math.pow(FRICTION_X, 60*dt);
    c.vy *= Math.pow(FRICTION_Y, 60*dt);

    if(c.y<=Y_TOP){
      c._collect=true;
      spawnParticles(c.x,c.y);
      triggerBarFX(c.x);
      continue;
    }
    if(c.y + c.rPhys > Y_BOTTOM){ c.y=Y_BOTTOM-c.rPhys; c.vy*=-0.15; }
  }

  for(let i=coins.length-1;i>=0;i--){
    const c=coins[i];
    if(!c._collect) continue;
    if(c.isRed){
      if(dzMode==='normal'){ dzMode='mega_push'; } else { megaQueue++; }
    }else if(c.isGreen){
      spawnSixPocketCoins();
    }else{
      bank++; if(bank>0) regenActive=false;
    }
    coins.splice(i,1);
  }
}

function collideEnv(){
  for(const c of coins) circleVsRect_UpwardPush(c, DZ_X, dzTop, DZ_W, DZ_H);
  for(const c of coins){
    circleVsSegment(c, LT_INNER, LT_WALL, 7);
    circleVsSegment(c, RT_INNER, RT_WALL, 7);
  }
  for(const c of coins){
    circleVsRect(c, LEFT_BLOCK.x,LEFT_BLOCK.y,LEFT_BLOCK.w,LEFT_BLOCK.h,6);
    circleVsRect(c, RIGHT_BLOCK.x,RIGHT_BLOCK.y,RIGHT_BLOCK.w,RIGHT_BLOCK.h,6);
  }
  for(const c of coins){
    if(c.y>=PIT_LEFT.y && c.y<=PIT_LEFT.y+PIT_LEFT.h){ if(c.x<=X_LEFT) c._burn=true; }
    else { if(c.x - c.rPhys < X_LEFT){ c.x=X_LEFT+c.rPhys; c.vx*=-0.08; } }
    if(c.y>=PIT_RIGHT.y && c.y<=PIT_RIGHT.y+PIT_RIGHT.h){ if(c.x>=X_RIGHT) c._burn=true; }
    else { if(c.x + c.rPhys > X_RIGHT){ c.x=X_RIGHT-c.rPhys; c.vx*=-0.08; } }
  }
  for(let i=coins.length-1;i>=0;i--) if(coins[i]._burn) coins.splice(i,1);
}

function separateCoins(){
  for(let it=0;it<2;it++){
    for(let i=0;i<coins.length;i++){
      for(let j=i+1;j<coins.length;j++){
        const a=coins[i], b=coins[j];
        const dx=b.x-a.x, dy=b.y-a.y, md=a.rPhys+b.rPhys, d2=dx*dx+dy*dy;
        if(d2<md*md){
          const d=Math.sqrt(d2)||0.0001, nx=dx/d, ny=dy/d, ov=(md-d)*CONTACT_STIFF;
          a.x-=nx*ov; a.y-=ny*ov; b.x+=nx*ov; b.y+=ny*ov;
          a.vx-=nx*SIDE_IMP*0.5; a.vy-=ny*SIDE_IMP*0.5;
          b.vx+=nx*SIDE_IMP*0.5; b.vy+=ny*SIDE_IMP*0.5;
          a.vx*=CONTACT_DAMP; a.vy*=CONTACT_DAMP;
          b.vx*=CONTACT_DAMP; b.vy*=CONTACT_DAMP;
        }
      }
    }
  }
}

// regen
function updateRegen(dt){
  if(!regenActive) return;
  regenTick += dt;
  while(regenTick>=1){
    regenTick-=1; regenLeft=Math.max(0,regenLeft-1);
    if(regenLeft===0){ bank+=1; regenActive=false; }
  }
}

// ---------- Draw ----------
function drawTopBar(){
  // базовый тёмно-красный градиент (как просил)
  let g=ctx.createLinearGradient(0,0,0,TOP);
  g.addColorStop(0,"#1b0f12");
  g.addColorStop(1,"#6a1414");
  ctx.fillStyle=g; ctx.fillRect(0,0,W,TOP);

  // перелив
  if(barAnimT>0){
    const t = 1 - (barAnimT / BAR_ANIM_DUR);
    const shift = (Math.sin(t*Math.PI*2)+1)/2;
    const gg = ctx.createLinearGradient(0,0,W,0);
    gg.addColorStop(Math.max(0,0.00+shift*0.1), "#8b5cf6");
    gg.addColorStop(Math.max(0,0.25+shift*0.1), "#60a5fa");
    gg.addColorStop(Math.min(1,0.50+shift*0.1), "#ffffff");
    gg.addColorStop(Math.min(1,0.75+shift*0.1), "#60a5fa");
    gg.addColorStop(Math.min(1,1.00),           "#8b5cf6");
    ctx.globalAlpha=0.65; ctx.fillStyle=gg; ctx.fillRect(0,0,W,TOP); ctx.globalAlpha=1;

    const stripeX = (t*W*1.4) % (W+400) - 200;
    const stripe = ctx.createLinearGradient(stripeX-120,0,stripeX+120,0);
    stripe.addColorStop(0,"rgba(255,255,255,0)");
    stripe.addColorStop(0.5,"rgba(255,255,255,0.9)");
    stripe.addColorStop(1,"rgba(255,255,255,0)");
    ctx.globalAlpha=0.35; ctx.fillStyle=stripe; ctx.fillRect(0,0,W,TOP); ctx.globalAlpha=1;
  }

  // твинклы и вспышки
  ctx.save(); ctx.beginPath(); ctx.rect(0,0,W,TOP); ctx.clip();
  for(const s of twinkles){
    const a = 0.35 + 0.65*(0.5+0.5*Math.sin(s.phase));
    ctx.globalAlpha=a; ctx.fillStyle="#ffffff";
    ctx.fillRect(s.x - s.r/2, s.y - 0.5, s.r, 1);
    ctx.fillRect(s.x - 0.5,   s.y - s.r/2, 1,  s.r);
    ctx.beginPath(); ctx.arc(s.x,s.y,0.8,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;
  ctx.globalCompositeOperation="lighter";
  for(const b of barBursts){
    ctx.globalAlpha=Math.max(0,b.life);
    ctx.fillStyle="#ffffff"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalCompositeOperation="source-over";
  ctx.restore();

  // текст
  ctx.fillStyle="#fff"; ctx.textAlign="left"; ctx.textBaseline="middle";
  ctx.font="bold 33px system-ui";
  if(regenActive) ctx.fillText(`COINS: ${bank}  (${regenLeft}s)`, 40, TOP/2);
  else            ctx.fillText(`COINS: ${bank}`,               40, TOP/2);
}

function drawChannel(){ ctx.fillStyle="#006ee9"; ctx.fillRect(X_LEFT,Y_TOP,CHANNEL_W,Y_CHANNEL_BOTTOM-Y_TOP); }

function drawSideWallsAndPits(){
  ctx.fillStyle="#c82b2e";
  ctx.fillRect(0,TOP, X_LEFT, H-TOP);
  ctx.fillRect(X_RIGHT,TOP, W-X_RIGHT, H-TOP);
  ctx.fillStyle="#000";
  ctx.fillRect(0, PIT_LEFT.y, PIT_VIS_W, PIT_LEFT.h);
  // <<< ФИКС: корректные width/height для правого кармана
  ctx.fillRect(W-PIT_VIS_W, PIT_RIGHT.y, PIT_VIS_W, PIT_RIGHT.h);
}

function drawCorners(){
  ctx.fillStyle="#ff7b44";
  ctx.beginPath(); ctx.moveTo(LT_INNER.x,LT_INNER.y); ctx.lineTo(LT_CORNER.x,LT_CORNER.y); ctx.lineTo(LT_WALL.x,LT_WALL.y); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(RT_INNER.x,RT_INNER.y); ctx.lineTo(RT_CORNER.x,RT_CORNER.y); ctx.lineTo(RT_WALL.x,RT_WALL.y); ctx.closePath(); ctx.fill();
}

function drawDock(){
  ctx.fillStyle="#ff2f2f";
  ctx.fillRect(LEFT_BLOCK.x, LEFT_BLOCK.y, LEFT_BLOCK.w, LEFT_BLOCK.h);
  ctx.fillRect(RIGHT_BLOCK.x,RIGHT_BLOCK.y,RIGHT_BLOCK.w,RIGHT_BLOCK.h);
  ctx.fillStyle="#152623";
  ctx.fillRect(POCKET.x, POCKET.y, POCKET.w, POCKET.h);
}

function drawDozer(){ ctx.fillStyle="#75f80c"; ctx.fillRect(DZ_X,dzTop,DZ_W,DZ_H); }

function drawCoins(){
  for(const c of coins){
    const drawR = c.isGreen ? COIN_R_DRAW*2 : COIN_R_DRAW;
    if(c.isRed){
      ctx.fillStyle="#520000"; ctx.beginPath(); ctx.arc(c.x,c.y+10,drawR,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#ff2a2a"; ctx.beginPath(); ctx.arc(c.x,c.y,drawR,0,Math.PI*2); ctx.fill();
      ctx.lineWidth=3; ctx.strokeStyle="#aa1010"; ctx.stroke();
    }else if(c.isGreen){
      ctx.fillStyle="#0b3d0b"; ctx.beginPath(); ctx.arc(c.x,c.y+10,drawR,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#32ff72"; ctx.beginPath(); ctx.arc(c.x,c.y,drawR,0,Math.PI*2); ctx.fill();
      ctx.lineWidth=3; ctx.strokeStyle="#14a84a"; ctx.stroke();
    }else{
      ctx.fillStyle="#d87b00"; ctx.beginPath(); ctx.arc(c.x,c.y+10,drawR,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#fff230"; ctx.beginPath(); ctx.arc(c.x,c.y,drawR,0,Math.PI*2); ctx.fill();
      ctx.lineWidth=3; ctx.strokeStyle="#b86a00"; ctx.stroke();
    }
  }
}

// Tutorial spotlight
function drawRoundedHole(x,y,w,h,r=22){
  ctx.fillStyle="rgba(0,0,0,0.8)";
  ctx.fillRect(0,0,W,H);
  ctx.globalCompositeOperation="destination-out";
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y, x+w,y+r, r);
  ctx.arcTo(x+w,y+h, x+w-r,y+h, r);
  ctx.arcTo(x,y+h, x,y+h-r, r);
  ctx.arcTo(x,y, x+r,y, r);
  ctx.closePath(); ctx.fill();
  ctx.globalCompositeOperation="source-over";
  ctx.strokeStyle="rgba(140,255,120,0.9)";
  ctx.lineWidth=6; ctx.shadowColor="rgba(80,255,120,0.55)";
  ctx.shadowBlur=24; ctx.stroke(); ctx.shadowBlur=0;
}
function drawTutorial(){
  if(!tutorial.visible) return;
  drawRoundedHole(DZ_X, dzTop, DZ_W, DZ_H, 24);
  ctx.fillStyle="#ffffff"; ctx.font="bold 64px system-ui";
  ctx.textAlign="center"; ctx.textBaseline="bottom";
  ctx.fillText("Клади монеты сюда!", W/2, POCKET.y - 28);
}

// ---------- Loop ----------
function update(dt){
  updDozer(dt);
  updCoins(dt);
  collideEnv();
  separateCoins();
  updParticles(dt);
  updateRegen(dt);
  updateTopBarFX(dt);
}
function draw(){
  ctx.clearRect(0,0,W,H);
  drawTopBar();
  drawChannel();
  drawSideWallsAndPits();
  drawCorners();
  drawDock();
  drawDozer();
  drawCoins();
  drawParticles();
  drawTutorial();
}

let last=performance.now();
function loop(t){ const dt=(t-last)/1000; last=t; update(dt); draw(); requestAnimationFrame(loop); }

// ---------- Boot ----------
cvs.addEventListener('mousedown', handleInput);
cvs.addEventListener('touchstart', handleInput, {passive:false});
initCoins();
addEventListener('load', ()=>{ resize(); last=performance.now(); requestAnimationFrame(loop); });
addEventListener('resize', resize);
})();
</script>
</body>
</html>
