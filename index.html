<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dozer — edge pits & center-touch collect</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    width: 100%;
    height: 100%;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  #gameCanvas {
    position: absolute;
    top: 0; left: 0;
    width: 1080px; height: 1920px;
    transform-origin: top left;
    display: block;
    background: #000;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1080" height="1920"></canvas>

<script>
(() => {
  // ---------- Layout ----------
  const W=1080,H=1920;
  const TOP_BAR=140;

  const R=64, D=R*2;
  const CHANNEL_W = D*7;
  const CHANNEL_X = W/2 - CHANNEL_W/2;
  const CHANNEL_TOP = TOP_BAR;

  const DOCK_H=260;
  const DOCK_TOP = H-DOCK_H;
  const CHANNEL_BOTTOM = DOCK_TOP;

  // dozer
  const DOZER_W = CHANNEL_W*0.6;
  const DOZER_H = 360;
  const DOZER_X = W/2 - DOZER_W/2;
  const DOZER_TOP_MAX = DOCK_TOP;
  const DOZER_TOP_MIN = H + 80;
  const DOZER_PUSH_V = 280;
  const DOZER_BACK_V = 380;

  // pocket (spawn zone)
  const POCKET_X = DOZER_X;
  const POCKET_W = DOZER_W;
  const POCKET_Y = CHANNEL_BOTTOM;
  const POCKET_BOTTOM = POCKET_Y + DOCK_H;

  // arena limits
  const Y_TOP = CHANNEL_TOP;
  const Y_BOTTOM = POCKET_BOTTOM;
  const X_LEFT  = CHANNEL_X;
  const X_RIGHT = CHANNEL_X + CHANNEL_W;

  // bottom hard red blocks
  const leftBlock  = {x: CHANNEL_X,         y: CHANNEL_BOTTOM, w: POCKET_X-CHANNEL_X,                h: DOCK_H};
  const rightBlock = {x: POCKET_X+POCKET_W, y: CHANNEL_BOTTOM, w: X_RIGHT-(POCKET_X+POCKET_W),       h: DOCK_H};

  // ---------- Side pits at edges ----------
  // Визуальные чёрные шахты прямо от краёв экрана, НЕ заходят в канал.
  // Сгорание — когда ЦЕНТР монеты пересекает линию канала (X_LEFT/X_RIGHT) и её y попал в окно.
  const PIT_TOP    = CHANNEL_TOP + D*1.4;
  const PIT_BOTTOM = CHANNEL_BOTTOM - D*1.8;
  const PIT_H      = Math.max(60, PIT_BOTTOM - PIT_TOP);
  const PIT_VIS_W  = Math.min(60, CHANNEL_X - 8); // ширина чёрной полосы от края
  const leftPit  = {y: PIT_TOP,  h: PIT_H};
  const rightPit = {y: PIT_TOP,  h: PIT_H};

  // ---------- Physics ----------
  const GRAVITY=0.6, FRICTION=0.999, CONTACT_DAMP=0.94, CONTACT_STIFF=0.28;

  // ---------- Economy ----------
  const START_COINS=50;
  let bank=START_COINS, regenUnlocked=false, regenTimer=15, REGEN_PERIOD=15;

  // ---------- State ----------
  const canvas=document.getElementById('gameCanvas');
  const ctx=canvas.getContext('2d');
  let dozerTopY=DOZER_TOP_MIN, dozerPhase='push';
  const coins=[], particles=[];

  // ---------- Utils ----------
  function resize(){
    const s=Math.min(window.innerWidth/W, window.innerHeight/H);
    canvas.style.transform=`scale(${s})`;
    canvas.style.left=`${(window.innerWidth - W*s)/2}px`;
    canvas.style.top =`${(window.innerHeight - H*s)/2}px`;
  }
  function rand(a,b){return a+Math.random()*(b-a);}
  function toGame(evt){
    const r=canvas.getBoundingClientRect();
    const sx=W/r.width, sy=H/r.height;
    const cx=(evt.touches?evt.touches[0].clientX:evt.clientX)-r.left;
    const cy=(evt.touches?evt.touches[0].clientY:evt.clientY)-r.top;
    return {x:cx*sx,y:cy*sy};
  }
  function yInPit(y,p){return y>=p.y && y<=p.y+p.h;}

  // ---------- Spawns ----------
  function spawnCoinAt(x,y){ coins.push({x,y,r:R,vx:0,vy:0}); }
  function trySpawn(evt){
    evt.preventDefault();
    if (bank<=0) return;
    const {x,y}=toGame(evt);
    if (x<POCKET_X || x>POCKET_X+POCKET_W || y<POCKET_Y || y>POCKET_BOTTOM) return;
    bank--;
    if (bank<=0 && !regenUnlocked){ regenUnlocked=true; regenTimer=REGEN_PERIOD; }
    spawnCoinAt(x,y);
  }
  function initCoins(){
    for(let i=0;i<START_COINS;i++){
      coins.push({
        x: W/2 + rand(-CHANNEL_W*0.25, CHANNEL_W*0.25),
        y: rand(CHANNEL_TOP+R+40, CHANNEL_BOTTOM-R-40),
        r:R, vx:rand(-50,50), vy:rand(-30,30)
      });
    }
  }

  // ---------- Particles ----------
  function spawnParticles(x,y){
    for (let i=0;i<15;i++){
      particles.push({x,y,vx:rand(-100,100),vy:rand(-200,-50),life:1,size:rand(4,8)});
    }
  }
  function updParticles(dt){
    for(const p of particles){
      p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=200*dt; p.life-=1.5*dt;
    }
    for(let i=particles.length-1;i>=0;i--) if(particles[i].life<=0) particles.splice(i,1);
  }

  // ---------- Dozer ----------
  function updDozer(dt){
    if(dozerPhase==='push'){
      dozerTopY-=DOZER_PUSH_V*dt;
      if(dozerTopY<DOZER_TOP_MAX){dozerTopY=DOZER_TOP_MAX; dozerPhase='back';}
    }else{
      dozerTopY+=DOZER_BACK_V*dt;
      if(dozerTopY>DOZER_TOP_MIN){dozerTopY=DOZER_TOP_MIN; dozerPhase='push';}
    }
  }

  // ---------- Collisions ----------
  function circleVsRect(c, rx,ry,rw,rh, push=10){
    let cx=Math.max(rx, Math.min(c.x, rx+rw));
    let cy=Math.max(ry, Math.min(c.y, ry+rh));
    const dx=c.x-cx, dy=c.y-cy, d2=dx*dx+dy*dy, r2=c.r*c.r;
    if(d2<r2){
      const d=Math.sqrt(d2)||0.0001, ov=c.r-d, nx=dx/d, ny=dy/d;
      c.x+=nx*ov; c.y+=ny*ov;
      c.vx+=nx*push; c.vy+=ny*push;
      c.vx*=CONTACT_DAMP; c.vy*=CONTACT_DAMP;
    }
  }
  function collideEnvironment(){
    // dozer
    for(const c of coins) circleVsRect(c, DOZER_X, dozerTopY, DOZER_W, DOZER_H, 10);

    // bottom red blocks
    for(const c of coins) circleVsRect(c, leftBlock.x,  leftBlock.y,  leftBlock.w,  leftBlock.h, 6);
    for(const c of coins) circleVsRect(c, rightBlock.x, rightBlock.y, rightBlock.w, rightBlock.h,6);

    // side walls + edge pits: burn only if CENTER crosses the channel line and y in pit window
    for(const c of coins){
      // LEFT channel edge
      if (yInPit(c.y,leftPit) && c.x <= X_LEFT) { c._burn=true; continue; }
      if (c.x - c.r < X_LEFT) { c.x = X_LEFT + c.r; c.vx *= -0.15; }

      // RIGHT channel edge
      if (yInPit(c.y,rightPit) && c.x >= X_RIGHT) { c._burn=true; continue; }
      if (c.x + c.r > X_RIGHT) { c.x = X_RIGHT - c.r; c.vx *= -0.15; }
    }
  }

  function separateCoins(){
    for(let it=0;it<2;it++){
      for(let i=0;i<coins.length;i++){
        for(let j=i+1;j<coins.length;j++){
          const a=coins[i], b=coins[j];
          const dx=b.x-a.x, dy=b.y-a.y, md=a.r+b.r, d2=dx*dx+dy*dy;
          if(d2<md*md){
            const d=Math.sqrt(d2)||0.0001, nx=dx/d, ny=dy/d, ov=(md-d)*CONTACT_STIFF;
            a.x-=nx*ov; a.y-=ny*ov; b.x+=nx*ov; b.y+=ny*ov;
            const SIDE=2;
            a.vx-=nx*SIDE*0.5; a.vy-=ny*SIDE*0.5;
            b.vx+=nx*SIDE*0.5; b.vy+=ny*SIDE*0.5;
            a.vx*=CONTACT_DAMP; a.vy*=CONTACT_DAMP;
            b.vx*=CONTACT_DAMP; b.vy*=CONTACT_DAMP;
          }
        }
      }
    }
  }

  // ---------- Coins update ----------
  function updCoins(dt){
    for(const c of coins){
      c.vy+=GRAVITY*dt;
      c.y +=c.vy*dt;
      c.x +=c.vx*dt;
      c.vx*=FRICTION; c.vy*=FRICTION;

      // collect by CENTER at top
      if (c.y <= Y_TOP) { spawnParticles(c.x,c.y); bank++; c._collected=true; }

      // floor clamp
      if (c.y + c.r > Y_BOTTOM){ c.y = Y_BOTTOM - c.r; c.vy *= -0.2; }
    }
    for(let i=coins.length-1;i>=0;i--) if(coins[i]._collected||coins[i]._burn) coins.splice(i,1);
  }

  // ---------- Bank ----------
  function updBank(dt){
    if(!regenUnlocked) return;
    regenTimer -= dt;
    if (regenTimer<=0){ regenTimer+=REGEN_PERIOD; bank++; }
  }

  // ---------- Drawing ----------
  function drawTopBar(){
    const g=ctx.createLinearGradient(0,0,0,TOP_BAR);
    g.addColorStop(0,"#2fd144"); g.addColorStop(1,"#1a6f2f");
    ctx.fillStyle=g; ctx.fillRect(0,0,W,TOP_BAR);
    ctx.fillStyle="#fff"; ctx.font="bold 64px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle";
    if(!regenUnlocked) ctx.fillText(`COINS: ${bank}`, W/2, TOP_BAR/2);
    else if(bank>0)    ctx.fillText(`COINS: ${bank}`, W/2, TOP_BAR/2);
    else               ctx.fillText(`COINS: ${bank} (${Math.ceil(regenTimer)})`, W/2, TOP_BAR/2);
  }
  function drawChannel(){
    ctx.fillStyle="#0b4f8a";
    ctx.fillRect(CHANNEL_X, CHANNEL_TOP, CHANNEL_W, CHANNEL_BOTTOM-CHANNEL_TOP);
  }
  function drawSideWallsAndEdgePits(){
    // red side walls
    ctx.fillStyle="#ff4f4f";
    ctx.fillRect(0, TOP_BAR, CHANNEL_X, H-TOP_BAR);
    ctx.fillRect(CHANNEL_X+CHANNEL_W, TOP_BAR, W-(CHANNEL_X+CHANNEL_W), H-TOP_BAR);
    // black pits at edges (purely visual; burn happens on channel line)
    ctx.fillStyle="#000";
    ctx.fillRect(0, leftPit.y, PIT_VIS_W, leftPit.h);                                 // left edge
    ctx.fillRect(W-PIT_VIS_W, rightPit.y, PIT_VIS_W, rightPit.h);                     // right edge
  }
  function drawDock(){
    ctx.fillStyle="#ff4f4f";
    ctx.fillRect(leftBlock.x, leftBlock.y, leftBlock.w, leftBlock.h);
    ctx.fillRect(rightBlock.x,rightBlock.y,rightBlock.w,rightBlock.h);
    ctx.fillStyle="#000";
    ctx.fillRect(POCKET_X, CHANNEL_BOTTOM, POCKET_W, DOCK_H);
  }
  function drawDozer(){
    ctx.fillStyle="#6aff1f";
    ctx.fillRect(DOZER_X, dozerTopY, DOZER_W, DOZER_H);
  }
  function drawCoins(){
    for(const c of coins){
      ctx.fillStyle="#d87b00"; ctx.beginPath(); ctx.arc(c.x, c.y+10, c.r, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="#fff230"; ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI*2); ctx.fill();
      ctx.lineWidth=3; ctx.strokeStyle="#b86a00"; ctx.stroke();
    }
  }
  function drawParticles(){
    for(const p of particles){
      ctx.globalAlpha=p.life;
      ctx.fillStyle="#fff230";
      ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }
  }
  function drawAll(){
    ctx.clearRect(0,0,W,H);
    drawTopBar();
    drawChannel();
    drawSideWallsAndEdgePits();
    drawDock();
    drawDozer();
    drawCoins();
    drawParticles();
  }

  // ---------- Loop ----------
  function updateAll(dt){
    updDozer(dt);
    updCoins(dt);
    collideEnvironment();
    separateCoins();
    updBank(dt);
    updParticles(dt);
  }
  let last=performance.now();
  function loop(ts){
    const dt=(ts-last)/1000; last=ts;
    updateAll(dt);
    drawAll();
    requestAnimationFrame(loop);
  }

  // ---------- Boot ----------
  canvas.addEventListener('mousedown', trySpawn);
  canvas.addEventListener('touchstart', trySpawn, {passive:false});
  initCoins();
  window.addEventListener('load', ()=>{ resize(); last=performance.now(); requestAnimationFrame(loop); });
  window.addEventListener('resize', resize);
})();
</script>
</body>
</html>
